import random
import threading
from threading import Lock
import time
from datetime import datetime
from flask import Flask, render_template,request
from flask_socketio import SocketIO, emit, join_room, leave_room
import json
import firebase_admin
from flask_cors import CORS
from firebase_admin import credentials
from firebase_admin import db

# Replace with the path to your service account key file (ensure secure storage)
cred = credentials.Certificate("credentials.json")
firebase_admin.initialize_app(cred, {
    "databaseURL": "https://guardian-6fe62-default-rtdb.firebaseio.com/"
})

"""
Background Thread
"""
thread = None
thread_lock = Lock()
exit_flag = False


app = Flask(__name__)
app.config['SECRET_KEY'] = 'secret!'
cors = CORS(app)
socketio = SocketIO(app, cors_allowed_origins="*")

#Global variables
fan_status = "off"
fan_mode = "auto"
pump_status = "off"
pump_mode = "auto"
heater_status = "off"
heater_mode = "auto"
light_status = "off"
light_mode = "auto"

# For now I will keep this since the data from the arduino is not here yet
temperature_threshold = 0
humidity_threshold = 0
light_threshold = 0
moisture_threshold = 0


# Access the Realtime Database reference
root_ref = db.reference('/')  # Reference to the root of the database


reading_ref = root_ref.child('reading')
actuator_ref = root_ref.child('actuator')
notification_ref = root_ref.child('notifications')
counter_ref = root_ref.child('counter')

def save_reading_to_firebase(data,server_time):   
    
    time_stamp_key = datetime.now().strftime("%m\%d\%Y %H:%M:%S")    
    reading_ref.child(server_time).set(data)
    # print(reading_ref.get())
    
def save_actuator_to_firebase(data,server_time):   
    
    time_stamp_key = datetime.now().strftime("%m\%d\%Y %H:%M:%S")    
    actuator_ref.child(server_time).set(data)
    # print(reading_ref.get())
      
    
@app.route('/')
def index():
    # You can render an HTML page for user interaction if desired
    return render_template()



@socketio.on('join')
def handle_join(data):
    room = data['room']
    join_room(room)
    # emit('response', {'data': f'Joined room: {room}'})

@socketio.on('leave')
def handle_leave(data):
    room = data['room']
    leave_room(room)
    # emit('response', {'data': f'Left room: {room}'})
    
"""
Decorator for connect
"""
@socketio.on('connect')
def connect():
    global thread
    print('Client connected')

    global thread
    with thread_lock:
        if thread is None:
            thread = socketio.start_background_task(background_thread)


"""
Decorator for disconnect
"""
@socketio.on('disconnect')
def disconnect():
    global exit_flag
    print('Client disconnected',  request.sid)
    exit_flag = True
    global thread
    thread.join()




"""
Get current date time
"""
def get_current_datetime():
    now = datetime.now()
    return now.strftime("%m\%d\%Y %H:%M:%S")

"""
Generate random sequence of dummy sensor values and send it to our clients
"""
def background_thread():
    """
        Remember that the dictionary will be from the arduino.
        Right now it's generated by the random value function.
    """
    
    print("Generating random sensor values")
    global exit_flag
    while not exit_flag:
        dummy_temperature_value = round(random.random() * 100, 3)
        dummy_humidity_value = round(random.random() * 100, 3)
        dummy_moisture_value = round(random.random() * 100, 3)
        dummy_light_value = round(random.random() * 100, 3)
        
        global fan_status
        global fan_mode
        global pump_status
        global pump_mode
        global heater_status
        global heater_mode
        global light_status
        global light_mode
        global temperature_threshold
        global light_threshold
        global humidity_threshold
        global moisture_threshold       
        
        server_time = get_current_datetime()

        
        dummy_reading_dict = {'temperature': dummy_temperature_value,
                              'temperature_threshold': temperature_threshold,
                              'humidity' : dummy_humidity_value,
                              'humidity_threshold': humidity_threshold,
                              'moisture' : dummy_moisture_value,
                              'moisture_threshold': moisture_threshold,
                              'light' : dummy_light_value,
                              'light_threshold': light_threshold,
                              'time': datetime.now().strftime('%H:%M:%S')                   
                            }
        
        dummy_actuator_dict = {
                                'fan_status': fan_status,
                                'fan_mode' :fan_mode,
                                'heater_status': heater_status,
                                'heater_mode' : heater_mode,
                                'pump_status': pump_status,
                                'pump_mode' : pump_mode,
                                'light_status':light_status,
                                'light_mode' : light_mode
                                }
        
        save_kpi(dummy_reading_dict)
        
        dummy_reading_data = json.dumps(dummy_reading_dict)
        dummy_actuator_data = json.dumps(dummy_actuator_dict)
        socketio.emit('updateSensorData', dummy_reading_dict)
        save_reading_to_firebase(dummy_reading_data,server_time)
        save_actuator_to_firebase(dummy_actuator_data,server_time)
        # notifications = notification_ref.get() or {}
        # socketio.emit('notification', notifications)
        socketio.sleep(1)    

def save_kpi(kpi):
    file_path = 'C:/Users/chima/OneDrive/Desktop/web/ephor/green-house-dashboard/src/crypt/db.json'
    today = time.strftime('%x')
    try:
        with open(file_path, 'r') as file:
            data = json.load(file)
            if today in data.keys():
                data[today].append(kpi)
            else:
                data[today] = [kpi]
        
        with open(file_path, 'w') as file:
            json.dump(data, file, indent=2)
    except Exception as e:
        print(f'error: {e}')

        
@socketio.on('control_arduino') 
def handle_control_arduino(data):
    
  print(type(data))
  """
  Handles the 'control_arduino' event from the client.

  Parses the JSON data and triggers the appropriate function based on the command.
  """
  try:
    global fan_status
    global fan_mode
    global pump_status
    global pump_mode
    global heater_status
    global heater_mode
    global light_status
    global light_mode     

    device, command = list(data.items())[0]
 
# Check if you have a valid command
    if command is not None:
        print(f"Extracted key: {device}, value: {command}")  # Assumes only one key-value pair
        
    else:
        pass

    # Implement logic to send the command to ESP based on device and command
    # Check mode and also the status of each actuator
    """summary_line
        I should keep a global variable for the status of each actuator ie ON/OFF and MANUAL/AUTO.
        This will be acquired from the messages before saving it to the database.
        
        I should have two modes for each actuator. Keep a
        variable in arduino for the mode of each actuator.
    """
    
    """I am checking if the command I have recieved is to update mode
        The format from the front-end client is {device : command}    
    """
    
    if device == "fan" and command == "auto":
        #Change mode to auto
        fan_mode = command
        emit("control_arduino",{ device : command})

    
    elif device == "fan" and command == "manual":
        #Change mode to manual
        fan_mode = command
        emit("control_arduino",{device : command})
    
    elif device == "heater" and command == "auto":
        #Change mode to auto
        heater_mode = command
        emit("control_arduino",{device : command})
    
    elif device == "heater" and command == "manual":
        #Change mode to manual
        heater_mode = command
        emit("control_arduino",{device : command})
    
    elif device == "pump" and command == "auto":
        #Change mode to auto
        pump_mode = command
        emit("control_arduino",{device : command})
    
    elif device == "pump" and command == "manual":
        #Change mode to manual
        pump_mode = command
        emit("control_arduino",{device : command})
    
    elif device == "light" and command == "auto":
        #Change mode to auto
        light_mode = command
        emit("control_arduino",{device : command})
    
    elif device == "light" and command == "manual":
        #Change mode to manual
        light_mode = command
        emit("control_arduino",{device : command})  
    
      

    elif device == "fan" and command == "on" or command == "off":
        if fan_mode == "manual":
            #update status
            if command == "on" and fan_status == "on":
                # Already on
                pass
            elif command == "on" and fan_status == "off":
                #Turn it on
                emit("control_arduino",{device : command}) 
            elif command == "off" and fan_status == "on":
                #Turn off
                emit("control_arduino",{device : command}) 
            else:
                #Already off
                pass
            
        
        else:
            #Change mode
            pass
        
    elif device == "heater" and command == "on" or command == "off":
        if heater_mode == "manual":
            #update status
            if command == "on" and heater_status == "on":
                # Already on
                pass
            elif command == "on" and heater_status == "off":
                #Turn it on
                emit("control_arduino",{device : command}) 
            elif command == "off" and heater_status == "on":
                #Turn off
                emit("control_arduino",{device : command}) 
            else:
                #Already off
                pass
            
        
        else:
            #Change mode
            pass
        
    elif device == "pump" and command == "on" or command == "off":
        if pump_mode == "manual":
            #update status
            if command == "on" and pump_status == "on":
                # Already on
                pass
            elif command == "on" and pump_status == "off":
                #Turn it on
                emit("control_arduino",{device : command}) 
            elif command == "off" and pump_status == "on":
                #Turn off
                emit("control_arduino",{device : command}) 
            else:
                #Already off
                pass
            
        
        else:
            #Change mode
            pass    
        
    elif device == "light" and command == "on" or command == "off":
        if light_mode == "manual":
            #update status
            if command == "on" and light_status == "on":
                # Already on
                pass
            elif command == "on" and light_status == "off":
                #Turn it on
                emit("control_arduino",{device : command}) 
            elif command == "off" and light_status == "on":
                #Turn off
                emit("control_arduino",{device : command}) 
            else:
                #Already off
                pass
            
        
        else:
            #Change mode
            pass
        
    else:
        #Invalid command
        pass 
      
       
    
  except Exception as e:
    print(f"Error processing control data: {e}")
    
    
# For the send notification, the arduino will send the actual notification,
# the server will just read it and pass it on.
# The logic for sending notifications will lie in the hands of the arduino
#The message format on the arduino will be {'alert' : message}

def get_next_key():
    # Use a transaction to increment the counter safely
    def increment_counter(current):
        return (current or 0) + 1
    
    global counter_ref
    new_key = counter_ref.transaction(increment_counter)
    return new_key
  
@socketio.on('send_alert')
def send_notification(message):
    global notification_ref
    notification_id = str(get_next_key())
    print(notification_id)
    notification = {
        'message': message.get('alert'),
        'timestamp': get_current_datetime()
    }
    notification_ref.child(notification_id).set(notification)
    socketio.emit('notification', notification)
    
    #When deleting the format is {'id' : 1} 
@socketio.on('delete_alert')
def handle_delete_notification(data):
    notification_id = data.get('id')
    notification_ref.child(notification_id).delete()
    notifications = notification_ref.get() or {}
    emit('notification', notifications)   
    
if __name__ == '__main__':
    # Start fetching data on application startup
    # fetch_data_from_firebase()
    
    socketio.run(app,allow_unsafe_werkzeug=True) 
    threading.Thread(target=background_thread).start()
   
    



